using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace SmartCardReaderLib
{
    /// <summary>
    /// Reads Credit cards
    /// </summary>
    public class CreditCard
    {
        // APDU commands are using 5 elements in this order
        // Then the data are added
        private const byte Cla = 0x00;
        private const byte Ins = 0x01;
        private const byte P1 = 0x02;
        private const byte P2 = 0x03;
        private const byte Lc = 0x04;

        private const int MaxBufferSize = 260;

        // This is a string "1PAY.SYS.DDF01" (PPSE) to select the root directory
        // This is usually represented as { 0x31, 0x50, 0x41, 0x59, 0x2e, 0x53, 0x59, 0x53, 0x2e, 0x44, 0x44, 0x46, 0x30, 0x31 }
        private static readonly byte[] RootDirectory1 = Encoding.ASCII.GetBytes("1PAY.SYS.DDF01");
        // This is a string "2PAY.SYS.DDF01" (PPSE) to select the root directory
        // this is usually represented  as { 0x32, 0x50, 0x41, 0x59, 0x2e, 0x53, 0x59, 0x53, 0x2e, 0x44, 0x44, 0x46, 0x30, 0x31 }
        private static readonly byte[] RootDirectory2 = Encoding.ASCII.GetBytes("2PAY.SYS.DDF01");

        private CardTransceiver _nfc;
        private bool _alreadyReadSfi = false;
        private byte _target;
        private ILogger? _logger = null;

        /// <summary>
        /// The size of the tailer elements. Some readers add an extra byte
        /// usually 0x00 especially NFC ones. While Smart Card readers usually do not
        /// </summary>
        public int TailerSize { get; set; }

        /// <summary>
        /// A list of Tags that is contained by the Credit Card
        /// </summary>
        public List<Tag> Tags { get; internal set; }

        /// <summary>
        /// The list of log entries in binary format
        /// </summary>
        public List<byte[]> LogEntries { get; internal set; }

        /// <summary>
        /// Create a Credit Card class
        /// </summary>
        /// <param name="nfc">A compatible Card reader</param>
        /// <param name="target">The target number as some readers needs it</param>
        /// <param name="tailerSize">Size of the tailer, most NFC readers add an extra byte 0x00</param>
        /// <remarks>The target number can be found with the NFC/Card reader you are using. For example the PN532 require a target number,
        /// the normal smart card readers usually don't as they only support 1 card at a time.</remarks>
        public CreditCard(CardTransceiver nfc, byte target, int tailerSize = 3)
        {
            _nfc = nfc;
            _target = target;
            Tags = new List<Tag>();
            LogEntries = new List<byte[]>();
            TailerSize = tailerSize;
        }

        /// <summary>
        /// Process external authentication
        /// </summary>
        /// <param name="issuerAuthenticationData">The authentication data</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> ProcessExternalAuthentication(Memory<byte> issuerAuthenticationData)
        {
            if ((issuerAuthenticationData.Length < 8) || (issuerAuthenticationData.Length > 16))
            {
                throw new ArgumentException(nameof(issuerAuthenticationData), "Data needs to be more than 8 and less than 16 bytes length");
            }

            var toSend = new Memory<byte>(new byte[5 + issuerAuthenticationData.Length]);
            ApduCommands.ExternalAuthenticate.CopyTo(toSend);
            toSend.Span[P1] = 0x00;
            toSend.Span[P2] = 0x00;
            toSend.Span[Lc] = (byte)issuerAuthenticationData.Length;
            issuerAuthenticationData.CopyTo(toSend.Slice(Lc));
            return await RunSimpleCommand(toSend);
        }

        private async Task<ErrorType> RunSimpleCommand(Memory<byte> toSend)
        {
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);
            if (ret >= TailerSize)
            {
                return new ProcessError(received.Slice(0, TailerSize).Span).ErrorType;
            }

            return ErrorType.Unknown;
        }

        /// <summary>
        /// Get a challenge to process authentication
        /// </summary>
        /// <param name="unpredictableNumber">the unpredictable number to be generated by the card, it should be 8 bytes</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> GetChallenge(Memory<byte> unpredictableNumber)
        {
            if (unpredictableNumber.Length < 8)
            {
                throw new ArgumentException(nameof(unpredictableNumber), "Data has to be at least 8 bytes long.");
            }

            var toSend = new Memory<byte>(new byte[5]);
            ApduCommands.GetChallenge.CopyTo(toSend);
            toSend.Span[P1] = 0x00;
            toSend.Span[P2] = 0x00;
            toSend.Span[P2 + 1] = 0x00;
            var ret = await ReadFromCard(_target, toSend, unpredictableNumber);
            if (ret >= TailerSize)
            {
                return new ProcessError(unpredictableNumber.Slice(0, TailerSize).Span).ErrorType;
            }

            return ErrorType.Unknown;
        }

        /// <summary>
        /// Verify the pin. Note this command may not be supported for your specific credit card
        /// </summary>
        /// <param name="pindigits">The pin in a byte array, between 4 and 8 array length. Pin numbers should be bytes like in the following example:
        /// byte[] pin = new byte[] { 1, 2, 3, 4 };
        /// </param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> VerifyPin(Memory<byte> pindigits)
        {
            // Pin can only be 4 to C length
            if ((pindigits.Length < 0x04) && (pindigits.Length > 0x0C))
            {
                throw new ArgumentException(nameof(pindigits), "Data can only be between 4 and 12 digits");
            }

            // Encode the pin
            // The plain text offline PIN block shall be formatted as follows:
            // C N P P P P P/F P/F P/F P/F P/F P/F P/F P/F F F
            // where:
            //     |   Name        |   Value
            // C   | Control field | 4 bit binary number with value of 0010 (Hex '2')
            // N   | PIN length    | 4 bit binary number with permissible values of 0100 to 1100 (Hex '4' to 'C')
            // P   | PIN digit     | 4 bit binary number with permissible values of 0000 to 1001 (Hex '0' to '9')
            // P/F | PIN/filler    | Determined by PIN length
            // F   | Filler        | 4 bit binary number with a value of 1111 (Hex 'F')
            byte[] encodedPin = new byte[2 + (pindigits.Length + 1) / 2];
            encodedPin[0] = (byte)(0b0010_0000 + pindigits.Length);
            int index = 1;
            for (int i = 0; i < pindigits.Length; i += 2)
            {
                encodedPin[index] = (byte)(pindigits.Span[i] << 4);
                if (i < (pindigits.Length - 1))
                {
                    encodedPin[index] += pindigits.Span[i + 1];
                }
                else
                {
                    encodedPin[index] += 0x0F;
                }

                index++;
            }

            encodedPin[index] = 0xFF;

            var toSend = new Memory<byte>(new byte[5 + encodedPin.Length]);
            ApduCommands.Verify.CopyTo(toSend);
            toSend.Span[P1] = 0x00;
            // We do support only plain text
            toSend.Span[P2] = 0b1000_0000;
            toSend.Span[Lc] = (byte)encodedPin.Length;
            encodedPin.CopyTo(toSend.Slice(Lc + 1));
            return await RunSimpleCommand(toSend);
        }

        /// <summary>
        /// Get the number of pin tries left. Your credit card may not support this command.
        /// Use GetData(DataType.PinTryCounter) instead if you get a -1 as answer
        /// </summary>
        /// <returns>the number of tries left or -1 if not successful</returns>
        public async Task<int> GetPinTries()
        {
            int tryLeft = -1;
            var toSend = new Memory<byte>(new byte[5]);
            ApduCommands.Verify.CopyTo(toSend);
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);

            if (ret == TailerSize)
            {
                var err = new ProcessError(received.Slice(0, TailerSize).Span);
                if ((err.ErrorType == ErrorType.StateNonVolatileMemoryChangedAuthenticationFailed) ||
                    (err.ErrorType == ErrorType.StateNonVolatileMemoryChanged))
                {
                    tryLeft = err.CorrectLegnthOrBytesAvailable;
                }
            }

            return tryLeft;
        }

        /// <summary>
        /// Select an application identifier
        /// </summary>
        /// <param name="correspondingApplicationIdentifier">This links the Tag to the corresponding App on the card</param>
        /// <param name="toSelect">The application identifier</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> Select(string correspondingApplicationIdentifier, Memory<byte> toSelect)
        {
            var toSend = new Memory<byte>(new byte[6 + toSelect.Length]);
            ApduCommands.Select.CopyTo(toSend);
            toSend.Span[P1] = 0x04;
            toSend.Span[P2] = 0x00;
            toSend.Span[Lc] = (byte)toSelect.Length;
            toSelect.CopyTo(toSend.Slice(Lc + 1));
            toSend.Span[toSend.Length - 1] = 0x00;
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);
            if (ret >= TailerSize)
            {
                if (ret == TailerSize)
                {
                    // It's an error, process it
                    var err = new ProcessError(received.Slice(0, TailerSize).Span);
                    return err.ErrorType;
                }

                FillTagList(correspondingApplicationIdentifier, Tags, received.Slice(0, ret - TailerSize).Span);

                return ErrorType.ProcessCompletedNormal;
            }

            return ErrorType.Unknown;
        }

        private void FillTagList(string correspondingApplicationIdentifier, List<Tag> tags, ReadOnlySpan<byte> span, uint parent = 0x00)
        {
            // We don't decode template 0x80
            if (span.Length == 0)
            {
                return;
            }

            var elem = new BerSplitter(span);
            foreach (var tag in elem.Tags)
            {
                // If it is a template or composed, then we need to split it
                if (tag.IsTemplateOrConstructed())
                {
                    tag.Tags ??= new List<Tag>();
                    FillTagList(correspondingApplicationIdentifier, tag.Tags, tag.Data, tag.TagNumber);
                }
                else
                {
                    // For debug
                }

                // Data Object Lists are special and not BER encoded, they have only the tag number encoded
                // Like for the traditional tags but the next element is a single byte indicating the size
                // Of the object
                if (tag.IsDol())
                {
                    tag.Tags ??= new List<Tag>();
                    DecodeDol(tag);
                }
                else
                {
                    // For debug
                }

                tag.Parent = parent;
                tag.CorrespondingApplicationIdentifier = correspondingApplicationIdentifier;
                tags.Add(tag);
            }
        }

        private void DecodeDol(Tag tag)
        {
            int index = 0;
            while (index < tag.Data.Length)
            {
                // Decode mono dimension (so 1 byte array) Ber elements but which can have ushort or byte tags
                var dol = new Tag();
                dol.Data = new byte[1];
                if ((tag.Data[index] & 0b0001_1111) == 0b0001_1111)
                {
                    dol.TagNumber = BinaryPrimitives.ReadUInt16BigEndian(tag.Data.AsSpan().Slice(index, 2));
                    index += 2;
                    tag.Data.AsSpan().Slice(index++, 1).CopyTo(dol.Data);
                }
                else
                {
                    dol.TagNumber = tag.Data[index++];
                    tag.Data.AsSpan().Slice(index++, 1).CopyTo(dol.Data);
                }

                dol.Parent = tag.TagNumber;
                tag.Tags.Add(dol);
            }
        }

        /// <summary>
        /// Gather all the public information present in the credit card.
        /// Fill then Tag list with all the found information. You can get
        /// all the credit card information in the Tags property.
        /// </summary>
        public async Task ReadCreditCardInformation()
        {
            var correspondingApplicationIdentifier = Encoding.Default.GetString(RootDirectory2);
            // This is a string "2PAY.SYS.DDF01" (PPSE) to select the root directory
            var ret = await Select(correspondingApplicationIdentifier, RootDirectory2);
            // If not working, then try with "1PAY.SYS.DDF01"
            if (ret != ErrorType.ProcessCompletedNormal)
            {
                correspondingApplicationIdentifier = Encoding.Default.GetString(RootDirectory1);
                ret = await Select(correspondingApplicationIdentifier, RootDirectory1);
            }

            if (ret == ErrorType.ProcessCompletedNormal)
            {
                if (!await FillTags(correspondingApplicationIdentifier))
                {
                    _alreadyReadSfi = false;
                    await FillTags(correspondingApplicationIdentifier);
                }
            }

            // Search for all tags with entries
            var entries = Tag.SearchTag(Tags, 0x9F4D).FirstOrDefault();
            if (entries is object)
            {
                // SFI entries is first byte and number of records is second one
                await ReadLogEntries(entries.Data[0], entries.Data[1]);
            }
        }

        /// <summary>
        /// Please refer to EMV 4.3 Book 3, Integrated Circuit Card Specifications for Payment Systems.
        /// https://www.emvco.com/emv-technologies/contact/. The file system and how to access it is mainly
        /// explained on chapter 5 and chapter 7.
        /// <param name="correspondingApplicationIdentifier">This links the Tag to the corresponding App on the card</param>
        /// </summary>
        /// <returns></returns>
        private async Task<bool> FillTags(string correspondingApplicationIdentifier)
        {
            // Find all Application Template = 0x61
            var appTemplates = Tags.GetApplicationTemplates();
            if (appTemplates.Count > 0)
            {
                await FillTagsFromAllTemplateAEFData(appTemplates);
                return true;
            }
            else
            {
                await FillTagsFromFileControlInformation_FCI_Template(correspondingApplicationIdentifier);
                return false;
            }
        }

        private async Task FillTagsFromAllTemplateAEFData(IReadOnlyList<Tag> appTemplates)
        {
            _logger?.LogDebug($"Number of App Templates: {appTemplates.Count}");
            foreach (var app in appTemplates)
            {
                await FillTagsFromTemplateAEFData(app);
            }
        }

        private async Task FillTagsFromTemplateAEFData(Tag app)
        {
            var appIdentifierTag = app.GetApplicationDedicatedFile_ADF_NameTag();
            var correspondingApplicationIdentifier = BitConverter.ToString(appIdentifierTag.Data);

            // do we have a PDOL tag 0x9F38
            _logger?.LogDebug($"APPID: {BitConverter.ToString(appIdentifierTag.Data)}");
            var ret = await Select(correspondingApplicationIdentifier, appIdentifierTag.Data);

            // Get few additional data
            await GetData(DataType.ApplicationTransactionCounter, correspondingApplicationIdentifier);
            await GetData(DataType.LastOnlineAtcRegister, correspondingApplicationIdentifier);
            await GetData(DataType.LogFormat, correspondingApplicationIdentifier);
            await GetData(DataType.PinTryCounter, correspondingApplicationIdentifier);

            if (ret != ErrorType.ProcessCompletedNormal)
            {
                return;
            }

            var templates = Tags.GetAll_FileControlTemplates_ThatContainPropertaryTemplates_ForThisApplicationIdentifier(appIdentifierTag.Data);
            var pdolTag = templates.GetFirst_PDOL_ProcessingOptionsDataObjectList_Tag_From_FileControlInformation_FCI_Tags();

            Memory<byte> received = new byte[260];
            byte sizeOfPdolResponse = 0;
            // Do we have a PDOL?
            if (pdolTag is object)
            {
                sizeOfPdolResponse = pdolTag.GetSizeOf_PDOL_ProcessingOptionsDataObjectList_Tag_Response();
            }

            // We send only 0 but the right number
            Memory<byte> pdolResponse = new byte[2 + sizeOfPdolResponse + 10];
            // Template command, Tag 83
            pdolResponse.Span.Set_PDOL_ProcessingOptionsDataObjectList_ResponseHeader(sizeOfPdolResponse);
            // If we have a PDOL, then we need to fill it properly
            // Some fields are mandatory
            int index = 2;
            if (pdolTag is object)
            {
                foreach (var dol in pdolTag.Tags)
                {
                    if (dol.TagNumber == TagNumberType.TerminalType)
                    {
                        pdolResponse.Span.Slice(index).AddPdolResponse(dol, new[]
                        {
                            PdolTags.TerminalType.Values.Merchant_AttendedOfflineOnly
                        });
                    }

                    // Transaction amount
                    else
                    if (dol.TagNumber == TagNumberType.AdditionalTerminalCapabilities)
                    {
                        pdolResponse.Span.Slice(index).AddPdolResponse(dol, new[]
                        {
                            PdolTags.AdditionalTerminalCapabilities.BitValues.Byte1_TransactionTypeCapability.All,
                            PdolTags.AdditionalTerminalCapabilities.BitValues.Byte2_TransactionTypeCapability.CashDeposit,
                            PdolTags.AdditionalTerminalCapabilities.BitValues.Byte3_TerminalDataInputCapability.All_No_RFU,
                            PdolTags.AdditionalTerminalCapabilities.BitValues.Byte4_TerminalDataOutputCapability.All_No_RFU,
                            PdolTags.AdditionalTerminalCapabilities.BitValues.Byte5_TerminalDataOutputCapability.All
                        });
                    }

                    // Transaction amount
                    else
                    // TerminalTransactionQualifier
                    if (dol.TagNumber == TagNumberType.TerminalCapabilities)
                    {
                        pdolResponse.Span.Slice(index).AddPdolResponse(dol, new[]
                        {
                            PdolTags.TerminalCapabilities.BitValues.Byte1_CardDataInputCapability.All_No_RFU,
                            PdolTags.TerminalCapabilities.BitValues.Byte2_CVMCapability.All_No_RFU,
                            PdolTags.TerminalCapabilities.BitValues.Byte3_SecurityCapability.All_No_RFU
                        });
                    }

                    // Transaction amount
                    else
                    // TerminalTransactionQualifier
                    if (dol.TagNumber == TagNumberType.TerminalTransactionQualifiers_TTQ)
                    {
                        pdolResponse.Span.Slice(index).AddPdolResponse(dol, new[]
                        {
                            (byte)(PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte1.MagStripeModeSupported |
                                   PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte1.EMVModeSupported |
                                   PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte1.EMVContactChipSupported |
                                   PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte1.OnlinePinSupported |
                                   PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte1.SignatureSupported),

                            PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte2.ContactChipOfflinePinSupported,

                            (byte)(PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte3.ConsumerDeviceCVMSupported |
                                   PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte3.IssuerUpdateProcessingSupported),

                            PdolTags.TerminalTransactionQualifiers_TTQ.BitValues.Byte4.No_RFU
                        });
                    }

                    // Transaction amount
                    else if (dol.TagNumber == TagNumberType.AmountAuthorized_Numeric)
                    {
                        // Ask authorization for the minimum, just to make sure
                        // It's more than 0
                        // 12 digits -> 6 bytes
                        // 0 -> msb
                        // msb must be padded with 0
                        pdolResponse.Span[index] = 0;
                        pdolResponse.Span[index + 1] = 0;
                        pdolResponse.Span[index + 2] = 0;
                        pdolResponse.Span[index + 3] = 0;
                        pdolResponse.Span[index + 4] = 0;
                        pdolResponse.Span[index + 5] = 1;
                        // here we have the amount 000000000001 units
                    }

                    // 9F1A-Terminal Country Code,
                    else if (dol.TagNumber == TagNumberType.TerminalCountryCode)
                    {
                        // Let's say we are in France
                        pdolResponse.Span[index] = 0x02;
                        pdolResponse.Span[index + 1] = 0x50;
                    }

                    // 009A-Transaction Date
                    else if (dol.TagNumber == TagNumberType.TransactionDate)
                    {
                        pdolResponse.Span[index] = NumberHelper.Dec2Bcd((DateTime.Now.Year % 100));
                        pdolResponse.Span[index + 1] = NumberHelper.Dec2Bcd((DateTime.Now.Month));
                        pdolResponse.Span[index + 2] = NumberHelper.Dec2Bcd((DateTime.Now.Day));
                    }

                    // 0x9F37 Unpredictable number
                    else if (dol.TagNumber == TagNumberType.UnpredictableNumber)
                    {
                        var randBytes = new byte[dol.Data[0]];
                        var rand = new Random();
                        rand.NextBytes(randBytes);
                        randBytes.AsSpan().CopyTo(pdolResponse.Span.Slice(index, dol.Data[0]));
                    }

                    // Currency
                    else if (dol.TagNumber == TagNumberType.TransactionCurrencyCode)
                    {
                        // We will ask for Euro
                        pdolResponse.Span[index] = 0x09;
                        pdolResponse.Span[index + 1] = 0x78;
                    }

                    index += dol.Data[0];
                }
            }

            // Ask for all the process options
            ret = await GetProcessingOptions(correspondingApplicationIdentifier, pdolResponse.Slice(0, index), received);
            Tag? appLocator = null;
            if (ret == ErrorType.ProcessCompletedNormal)
            {
                // Check if we have an Application File Locator 0x94 in 0x77
                var tg = Tag.SearchTag(Tags, 0x77);
                if (tg.Count > 0)
                {
                    appLocator = tg.Last().Tags.FirstOrDefault(t => t.TagNumber == 0x94);
                }
            }

            if ((ret == ErrorType.ProcessCompletedNormal) && (appLocator is object))
            {
                // Now decode the appLocator
                // Format is SFI - start - stop - number of records
                List<ApplicationDataDetail> details = new List<ApplicationDataDetail>();
                for (int i = 0; i < appLocator.Data.Length / 4; i++)
                {
                    var detail = new ApplicationDataDetail()
                    {
                        Sfi = (byte)(appLocator.Data[4 * i] >> 3),
                        Start = appLocator.Data[4 * i + 1],
                        End = appLocator.Data[4 * i + 2],
                        NumberOfRecords = appLocator.Data[4 * i + 3],
                    };
                    details.Add(detail);
                }

                // Now get all the records
                foreach (var detail in details)
                {
                    for (byte record = detail.Start; record < detail.End + 1; record++)
                    {
                        ret = await ReadRecord(correspondingApplicationIdentifier, detail.Sfi, record);
                        _logger?.LogDebug($"Read record {record}, SFI {detail.Sfi}, status: {ret}");
                    }

                }

                _alreadyReadSfi = true;
            }
            else if (!_alreadyReadSfi)
            {
                // We go thru all the SFI and first 5 records
                // According to the documentation, first 10 ones are supposed to
                // contain the core information
                for (byte record = 1; record < 5; record++)
                {
                    // 1 fro 10 is for Application Elementary Files
                    for (byte sfi = 1; sfi < 20; sfi++)
                    {
                        ret = await ReadRecord(correspondingApplicationIdentifier, sfi, record);
                        _logger?.LogDebug($"Read record {record}, SFI {sfi}, status: {ret}");
                    }
                }

                _alreadyReadSfi = true;
            }
        }

        private async Task FillTagsFromFileControlInformation_FCI_Template(string correspondingApplicationIdentifier)
        {
            // It's the old way, so looking for tag 0x88
            var appSfi = Tag.SearchTag(Tags, 0x88).FirstOrDefault();
            if (appSfi is object)
            {
                _logger?.LogDebug($"AppSFI: {appSfi.Data[0]}");
                for (byte record = 1; record < 10; record++)
                {
                    var ret = await ReadRecord(correspondingApplicationIdentifier, appSfi.Data[0], record);
                    _logger?.LogDebug($"Read record {record}, SFI {appSfi.Data[0]}, status: {ret}");
                }

                _alreadyReadSfi = true;
            }
        }

        /// <summary>
        /// Read log records
        /// </summary>
        public async Task ReadLogEntries(byte sfi, byte numberOfRecords)
        {
            // not yet implemented here
            var correspondingApplicationIdentifier = string.Empty;

            for (byte record = 1; record < numberOfRecords + 1; record++)
            {
                var ret = await ReadRecord(correspondingApplicationIdentifier, sfi, record, true);
                _logger?.LogDebug($"Read record {record}, SFI {sfi},status: {ret}");
            }
        }

        /// <summary>
        /// Read a specific record
        /// </summary>
        /// <param name="correspondingApplicationIdentifier">Links a Tag to the corresponding App on the card</param>
        /// <param name="sfi">The Short File Identifier</param>
        /// <param name="record">The Record to read</param>
        /// <param name="isLogEntry">Are we reading a log entry or something else?</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> ReadRecord(string correspondingApplicationIdentifier, byte sfi, byte record, bool isLogEntry = false)
        {
            if (sfi > 31)
            {
                return ErrorType.WrongParameterP1P2FunctionNotSupported;
            }

            var toSend = new Memory<byte>(new byte[5]);
            ApduCommands.ReadRecord.CopyTo(toSend.Span);
            toSend.Span[P1] = record;
            toSend.Span[P2] = (byte)((sfi << 3) | (0b0000_0100));
            toSend.Span[Lc] = 0x00;
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);
            if (ret >= TailerSize)
            {
                if (ret == TailerSize)
                {
                    // It's an error, process it
                    var err = new ProcessError(received.Span.Slice(0, TailerSize));
                    if (err.ErrorType == ErrorType.WrongLength)
                    {
                        toSend.Span[Lc] = err.CorrectLegnthOrBytesAvailable;
                        ret = await ReadFromCard(_target, toSend, received);
                        if (ret == TailerSize)
                        {
                            return new ProcessError(received.Span.Slice(0, TailerSize)).ErrorType;
                        }
                    }
                    else
                    {
                        return err.ErrorType;
                    }
                }

                if (isLogEntry)
                {
                    LogEntries.Add(received.Slice(0, ret - TailerSize).ToArray());
                }
                else
                {
                    FillTagList(correspondingApplicationIdentifier, Tags, received.Span.Slice(0, ret - TailerSize));
                }

                return new ProcessError(received.Span.Slice(ret - TailerSize)).ErrorType;
            }

            return ErrorType.Unknown;
        }

        /// <summary>
        /// Get Processing Options
        /// </summary>
        /// <param name="correspondingApplicationIdentifier">Links a Tag to the corresponding App on the card</param>
        /// <param name="pdolToSend">The PDOL array to send</param>
        /// <param name="pdol">The return PDOL elements</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> GetProcessingOptions(string correspondingApplicationIdentifier, ReadOnlyMemory<byte> pdolToSend, Memory<byte> pdol)
        {
            var toSend = new Memory<byte>(new byte[6 + pdolToSend.Length]);
            ApduCommands.GetProcessingOptions.CopyTo(toSend);
            toSend.Span[P1] = 0x00;
            toSend.Span[P2] = 0x00;
            toSend.Span[Lc] = (byte)(pdolToSend.Length);
            pdolToSend.CopyTo(toSend.Slice(Lc + 1));
            toSend.Span[Lc + pdolToSend.Length] = 0x00;
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);
            if (ret >= TailerSize)
            {
                if (ret == TailerSize)
                {
                    // It's an error, process it
                    return new ProcessError(received.Span.Slice(0, TailerSize)).ErrorType;
                }

                FillTagList(correspondingApplicationIdentifier, Tags, received.Span.Slice(0, ret - TailerSize));
                received.Slice(0, ret - TailerSize).CopyTo(pdol);
                return ErrorType.ProcessCompletedNormal;
            }

            return ErrorType.Unknown;
        }

        /// <summary>
        /// Get additional data
        /// </summary>
        /// <param name="dataType">The type of data to read</param>
        /// <param name="correspondingApplicationIdentifier">Links a Tag to the corresponding App on the card</param>
        /// <returns>The error status</returns>
        public async Task<ErrorType> GetData(DataType dataType, string correspondingApplicationIdentifier)
        {
            var toSend = new Memory<byte>(new byte[5]);
            ApduCommands.GetData.CopyTo(toSend);
            switch (dataType)
            {
                case DataType.ApplicationTransactionCounter:
                    // 9F36
                    toSend.Span[P1] = 0x9F;
                    toSend.Span[P2] = 0x36;
                    break;
                case DataType.PinTryCounter:
                    // 9F17
                    toSend.Span[P1] = 0x9F;
                    toSend.Span[P2] = 0x17;
                    break;
                case DataType.LastOnlineAtcRegister:
                    // 9F13
                    toSend.Span[P1] = 0x9F;
                    toSend.Span[P2] = 0x13;
                    break;
                case DataType.LogFormat:
                    // 9F4F
                    toSend.Span[P1] = 0x9F;
                    toSend.Span[P2] = 0x4F;
                    break;
                default:
                    break;
            }

            toSend.Span[Lc] = 0x00;
            var received = new Memory<byte>(new byte[MaxBufferSize]);
            var ret = await ReadFromCard(_target, toSend, received);
            if (ret >= TailerSize)
            {
                if (ret == TailerSize)
                {
                    // It's an error, process it
                    var err = new ProcessError(received.Span.Slice(0, TailerSize));
                    if (err.ErrorType == ErrorType.WrongLength)
                    {
                        toSend.Span[Lc] = err.CorrectLegnthOrBytesAvailable;
                        ret = await ReadFromCard(_target, toSend, received);
                        err = new ProcessError(received.Span.Slice(ret - TailerSize));
                        if (err.ErrorType != ErrorType.ProcessCompletedNormal)
                        {
                            return err.ErrorType;
                        }
                    }
                }

                FillTagList(correspondingApplicationIdentifier, Tags, received.Span.Slice(0, ret - TailerSize));
                _logger?.LogDebug($"{BitConverter.ToString(received.Slice(0, ret).ToArray())}");
                var ber = new BerSplitter(received.Span.Slice(0, ret - TailerSize));
                foreach (var b in ber.Tags)
                {
                    _logger?.LogDebug($"DataType: {dataType}, Tag: {b.TagNumber.ToString("X4")}, Data: {BitConverter.ToString(b.Data)}");
                }

                return new ProcessError(received.Span.Slice(ret - TailerSize)).ErrorType;
            }

            return ErrorType.Unknown;
        }

        private async Task<int> ReadFromCard(byte target, ReadOnlyMemory<byte> toSend, Memory<byte> received)
        {
            var ret = await _nfc.Transceive(_target, toSend, received);
            if (ret >= TailerSize)
            {
                if (ret == TailerSize)
                {
                    // It's an error, process it
                    var err = new ProcessError(received.Span.Slice(0, TailerSize));
                    if (err.ErrorType == ErrorType.BytesStillAvailable)
                    {
                        // Read the rest of the bytes
                        Memory<byte> toGet = new Memory<byte>(new byte[5]);
                        ApduCommands.GetBytesToRead.CopyTo(toGet);
                        toGet.Span[4] = err.CorrectLegnthOrBytesAvailable;
                        ret = await _nfc.Transceive(_target, toGet, received);
                    }
                }
            }

            return ret;
        }
    }
}
